[
    {
        "id": "advanced_plc_flow",
        "type": "tab",
        "label": "Advanced PLC Simulation",
        "disabled": false,
        "info": "M√¥ ph·ªèng n√¢ng cao v·ªõi c√°c scenario th·ª±c t·∫ø"
    },
    {
        "id": "main_timer",
        "type": "inject",
        "z": "advanced_plc_flow",
        "name": "Main Timer 3s",
        "props": [{"p": "payload"}],
        "repeat": "3",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 130,
        "y": 100,
        "wires": [["realistic_plc_simulation"]]
    },
    {
        "id": "realistic_plc_simulation",
        "type": "function",
        "z": "advanced_plc_flow",
        "name": "Realistic PLC Simulation",
        "func": "// ==================== H·ªÜ TH·ªêNG B·ªíN N∆Ø·ªöC TH·ª∞C T·∫æ ====================\n\nconst step = context.get('step') || 0;\ncontext.set('step', step + 1);\n\n// ==================== TR·∫†NG TH√ÅI H·ªÜ TH·ªêNG ====================\nlet state = context.get('systemState') || {\n    // Th√¥ng s·ªë v·∫≠t l√Ω\n    waterLevel: 45,        // % m·ª©c n∆∞·ªõc hi·ªán t·∫°i\n    pressure: 1.8,         // bar √°p su·∫•t hi·ªán t·∫°i\n    temperature: 25,       // ¬∞C nhi·ªát ƒë·ªô n∆∞·ªõc\n    \n    // Tr·∫°ng th√°i thi·∫øt b·ªã\n    pumpRunning: false,\n    valveOpen: false,\n    autoMode: true,\n    emergency: false,\n    \n    // Th√¥ng s·ªë v·∫≠n h√†nh\n    pumpRunTime: 0,        // Th·ªùi gian b∆°m ƒë√£ ch·∫°y (ph√∫t)\n    totalPumpCycles: 0,    // S·ªë l·∫ßn b∆°m ƒë√£ ch·∫°y\n    lastMaintenanceHours: 0, // Gi·ªù b·∫£o tr√¨ cu·ªëi\n    \n    // L·ªãch s·ª≠ ho·∫°t ƒë·ªông\n    dailyConsumption: 0,   // L√≠t ti√™u th·ª• trong ng√†y\n    peakHours: false,      // Gi·ªù cao ƒëi·ªÉm\n    \n    // C·∫£nh b√°o\n    alarmHistory: [],\n    lastAlarmTime: 0\n};\n\n// ==================== TH√îNG S·ªê V·∫¨T L√ù TH·ª∞C T·∫æ ====================\nconst TANK = {\n    CAPACITY: 1000,        // L√≠t\n    HEIGHT: 3.0,           // M√©t\n    DIAMETER: 1.5,         // M√©t\n    MIN_LEVEL: 10,         // % m·ª©c t·ªëi thi·ªÉu\n    MAX_LEVEL: 95,         // % m·ª©c t·ªëi ƒëa\n    CRITICAL_LOW: 15,      // % m·ª©c nguy hi·ªÉm th·∫•p\n    CRITICAL_HIGH: 90      // % m·ª©c nguy hi·ªÉm cao\n};\n\nconst PUMP = {\n    FLOW_RATE: 50,         // L√≠t/ph√∫t\n    MAX_PRESSURE: 4.0,     // bar\n    RATED_VOLTAGE: 220,    // V\n    POWER_CONSUMPTION: 1.5, // kW\n    START_PRESSURE: 1.0,   // bar √°p su·∫•t kh·ªüi ƒë·ªông\n    STOP_PRESSURE: 2.8     // bar √°p su·∫•t d·ª´ng\n};\n\nconst SYSTEM = {\n    UPDATE_INTERVAL: 3,    // gi√¢y\n    PRESSURE_PER_METER: 0.098, // bar/m (9.8 kPa/m)\n    AMBIENT_TEMP: 25,      // ¬∞C\n    TEMP_VARIATION: 5      // ¬∞C bi·∫øn thi√™n\n};\n\n// ==================== T√çNH TO√ÅN TI√äU TH·ª§ N∆Ø·ªöC THEO GI·ªú ====================\nconst currentHour = new Date().getHours();\nlet consumptionRate = 15; // L√≠t/ph√∫t c∆° b·∫£n\n\n// ƒêi·ªÅu ch·ªânh theo gi·ªù trong ng√†y\nif (currentHour >= 6 && currentHour <= 8) {\n    consumptionRate = 35; // Gi·ªù s√°ng cao ƒëi·ªÉm\n    state.peakHours = true;\n} else if (currentHour >= 11 && currentHour <= 13) {\n    consumptionRate = 30; // Gi·ªù tr∆∞a\n    state.peakHours = true;\n} else if (currentHour >= 17 && currentHour <= 20) {\n    consumptionRate = 40; // Gi·ªù t·ªëi cao ƒëi·ªÉm\n    state.peakHours = true;\n} else if (currentHour >= 22 || currentHour <= 5) {\n    consumptionRate = 8;  // Gi·ªù ƒë√™m th·∫•p ƒëi·ªÉm\n    state.peakHours = false;\n} else {\n    state.peakHours = false;\n}\n\n// Th√™m bi·∫øn thi√™n ng·∫´u nhi√™n ¬±20%\nconsumptionRate *= (0.8 + Math.random() * 0.4);\n\n// ==================== T√çNH TO√ÅN THAY ƒê·ªîI M·ª®C N∆Ø·ªöC ====================\nlet levelChange = 0;\nconst timeStep = SYSTEM.UPDATE_INTERVAL / 60; // Chuy·ªÉn sang ph√∫t\n\n// N∆∞·ªõc v√†o t·ª´ b∆°m\nif (state.pumpRunning) {\n    const pumpFlow = PUMP.FLOW_RATE * timeStep;\n    levelChange += (pumpFlow / TANK.CAPACITY) * 100;\n    state.pumpRunTime += timeStep;\n}\n\n// N∆∞·ªõc ra do ti√™u th·ª•\nconst outFlow = consumptionRate * timeStep;\nlevelChange -= (outFlow / TANK.CAPACITY) * 100;\nstate.dailyConsumption += outFlow;\n\n// C·∫≠p nh·∫≠t m·ª©c n∆∞·ªõc\nstate.waterLevel = Math.max(0, Math.min(100, state.waterLevel + levelChange));\n\n// ==================== T√çNH TO√ÅN √ÅP SU·∫§T ====================\n// √Åp su·∫•t tƒ©nh t·ª´ c·ªôt n∆∞·ªõc\nconst staticPressure = (state.waterLevel / 100) * TANK.HEIGHT * SYSTEM.PRESSURE_PER_METER;\n\n// √Åp su·∫•t ƒë·ªông t·ª´ b∆°m\nlet dynamicPressure = 0;\nif (state.pumpRunning) {\n    // √Åp su·∫•t b∆°m ph·ª• thu·ªôc v√†o m·ª©c n∆∞·ªõc v√† hi·ªáu su·∫•t\n    const pumpEfficiency = 0.8 + (state.waterLevel / 100) * 0.15; // 80-95%\n    dynamicPressure = 2.0 * pumpEfficiency;\n}\n\n// T·ªïng √°p su·∫•t v·ªõi nhi·ªÖu nh·ªè\nstate.pressure = staticPressure + dynamicPressure + (Math.random() - 0.5) * 0.1;\nstate.pressure = Number(state.pressure.toFixed(2));\n\n// ==================== LOGIC ƒêI·ªÄU KHI·ªÇN T·ª∞ ƒê·ªòNG ====================\nif (state.autoMode && !state.emergency) {\n    // Hysteresis control cho b∆°m\n    if (!state.pumpRunning) {\n        // ƒêi·ªÅu ki·ªán b·∫≠t b∆°m\n        if (state.waterLevel <= 25 || state.pressure <= PUMP.START_PRESSURE) {\n            state.pumpRunning = true;\n            state.totalPumpCycles++;\n            node.log(`üîµ B∆°m B·∫¨T: Level=${state.waterLevel.toFixed(1)}%, Pressure=${state.pressure}bar`);\n        }\n    } else {\n        // ƒêi·ªÅu ki·ªán t·∫Øt b∆°m\n        if (state.waterLevel >= 75 && state.pressure >= PUMP.STOP_PRESSURE) {\n            state.pumpRunning = false;\n            node.log(`üî¥ B∆°m T·∫ÆT: Level=${state.waterLevel.toFixed(1)}%, Pressure=${state.pressure}bar`);\n        }\n    }\n    \n    // ƒêi·ªÅu khi·ªÉn van\n    state.valveOpen = state.waterLevel < 70;\n}\n\n// ==================== T√çNH TO√ÅN NHI·ªÜT ƒê·ªò ====================\nstate.temperature = SYSTEM.AMBIENT_TEMP + \n    (Math.sin(step / 20) * SYSTEM.TEMP_VARIATION) + \n    (Math.random() - 0.5) * 2;\nstate.temperature = Number(state.temperature.toFixed(1));\n\n// ==================== ƒêI·ªÜN √ÅP V√Ä C√îNG SU·∫§T ====================\nlet voltage = 0;\nlet current = 0;\nif (state.pumpRunning) {\n    // ƒêi·ªán √°p dao ƒë·ªông quanh 220V\n    voltage = PUMP.RATED_VOLTAGE + (state.pressure - 2.0) * 8 + (Math.random() - 0.5) * 15;\n    voltage = Math.max(200, Math.min(240, voltage));\n    \n    // D√≤ng ƒëi·ªán ph·ª• thu·ªôc v√†o t·∫£i\n    current = (PUMP.POWER_CONSUMPTION * 1000) / voltage; // A\n    current *= (0.9 + state.pressure / 10); // ƒêi·ªÅu ch·ªânh theo √°p su·∫•t\n}\n\n// ==================== H·ªÜ TH·ªêNG C·∫¢NH B√ÅO ====================\nlet alarms = [];\n\n// Ki·ªÉm tra c√°c ƒëi·ªÅu ki·ªán c·∫£nh b√°o\nif (state.waterLevel <= TANK.CRITICAL_LOW) alarms.push('LOW_LEVEL');\nif (state.waterLevel >= TANK.CRITICAL_HIGH) alarms.push('HIGH_LEVEL');\nif (state.pressure > 3.5) alarms.push('OVER_PRESSURE');\nif (state.pressure < 0.5 && state.pumpRunning) alarms.push('LACK_PRESSURE');\nif (voltage > 235) alarms.push('OVER_VOLTAGE');\nif (voltage < 205 && state.pumpRunning) alarms.push('UNDER_VOLTAGE');\nif (state.temperature > 35) alarms.push('HIGH_TEMP');\nif (state.pumpRunTime > 60) alarms.push('PUMP_OVERRUN');\n\n// C·∫£nh b√°o b·∫£o tr√¨\nif (state.totalPumpCycles > 100 && (state.totalPumpCycles % 50) === 0) {\n    alarms.push('MAINTENANCE_DUE');\n}\n\n// Emergency ng·∫´u nhi√™n (1% c∆° h·ªôi)\nif (Math.random() < 0.01) {\n    state.emergency = !state.emergency;\n    if (state.emergency) {\n        alarms.push('EMERGENCY_STOP');\n        state.pumpRunning = false;\n        state.valveOpen = false;\n    }\n}\n\n// Chuy·ªÉn ch·∫ø ƒë·ªô ng·∫´u nhi√™n (3% c∆° h·ªôi)\nif (Math.random() < 0.03) {\n    state.autoMode = !state.autoMode;\n}\n\n// ==================== T·∫†O D·ªÆ LI·ªÜU OUTPUT ====================\nconst data = {\n    // C·∫£m bi·∫øn ch√≠nh\n    Sensors_Level: Math.round(state.waterLevel),\n    Sensors_Level_Per: Math.round(state.waterLevel),\n    Sensors_Pressure: state.pressure,\n    Sensors_Pressure_Per: Math.round((state.pressure / 4) * 100),\n    \n    // D·ªØ li·ªáu ƒë·∫ßu v√†o\n    Level_Input: Math.round(state.waterLevel),\n    Pressure_Input: state.pressure,\n    Level: Math.round(state.waterLevel),\n    Pressure: Math.round((state.pressure / 4) * 100),\n    \n    // Thi·∫øt b·ªã\n    Running_Pump: state.pumpRunning ? 1 : 0,\n    Valve_Solenoid: state.valveOpen ? 1 : 0,\n    \n    // Ch·∫ø ƒë·ªô\n    Auto_Mode: state.autoMode,\n    Manu_Mode: !state.autoMode,\n    status_Mode: state.autoMode ? 1 : 2,\n    Emergency: state.emergency,\n    \n    // ƒê√®n b√°o\n    Stt_Start_Light_Green: state.pumpRunning ? 1 : 0,\n    Stt_Stop_Light_Red: state.pumpRunning ? 0 : 1,\n    Stt_EMG_Light_yellow: state.emergency ? 1 : 0,\n    \n    // ƒêi·ªán\n    Value_Vollt_Actual: Number(voltage.toFixed(1)),\n    Current_Actual: Number(current.toFixed(2)),\n    Power_Consumption: Number((voltage * current / 1000).toFixed(2)),\n    \n    // Setpoints\n    Level_Setpoint: 60,\n    Pressure_Setpoint: 2.5,\n    \n    // C·∫£nh b√°o\n    Over_Pressure: alarms.includes('OVER_PRESSURE') ? 1 : 0,\n    Lack_of_Pressure: alarms.includes('LACK_PRESSURE') ? 1 : 0,\n    Over_Voltage: alarms.includes('OVER_VOLTAGE') ? 1 : 0,\n    High_Level: alarms.includes('HIGH_LEVEL') ? 1 : 0,\n    Low_Level: alarms.includes('LOW_LEVEL') ? 1 : 0,\n    \n    // Th√¥ng tin b·ªï sung\n    Temperature: state.temperature,\n    Pump_Runtime: Number(state.pumpRunTime.toFixed(1)),\n    Daily_Consumption: Number(state.dailyConsumption.toFixed(1)),\n    Pump_Cycles: state.totalPumpCycles,\n    Peak_Hours: state.peakHours,\n    \n    timestamp: new Date().toISOString()\n};\n\n// L∆∞u tr·∫°ng th√°i\ncontext.set('systemState', state);\n\n// Log chi ti·∫øt\nconst mode = state.autoMode ? 'AUTO' : 'MANUAL';\nconst emergency = state.emergency ? ' [EMERGENCY]' : '';\nconst peak = state.peakHours ? ' [PEAK]' : '';\nconst pumpStatus = state.pumpRunning ? 'ON' : 'OFF';\n\nnode.log(`Step ${step}: Level=${state.waterLevel.toFixed(1)}% (${levelChange > 0 ? '+' : ''}${levelChange.toFixed(2)}%), ` +\n         `Pressure=${state.pressure}bar, Pump=${pumpStatus}, Temp=${state.temperature}¬∞C, ` +\n         `Mode=${mode}${emergency}${peak}`);\n\nif (alarms.length > 0) {\n    node.log(`üö® ALARMS: ${alarms.join(', ')}`);\n}\n\nmsg.payload = data;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "x": 380,
        "y": 100,
        "wires": [["mqtt_out_advanced", "debug_advanced"]]
    },
    {
        "id": "mqtt_out_advanced",
        "type": "mqtt out",
        "z": "advanced_plc_flow",
        "name": "HiveMQ Advanced",
        "topic": "plc/data",
        "qos": "1",
        "retain": "false",
        "broker": "hivemq_broker",
        "x": 650,
        "y": 100,
        "wires": []
    },
    {
        "id": "debug_advanced",
        "type": "debug",
        "z": "advanced_plc_flow",
        "name": "Advanced Debug",
        "active": true,
        "tosidebar": true,
        "console": false,
        "complete": "payload",
        "targetType": "msg",
        "x": 650,
        "y": 160,
        "wires": []
    }
]
